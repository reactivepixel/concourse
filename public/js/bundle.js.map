{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","assets/js/main.js","assets/js/themeChanger.js","node_modules/browserify/node_modules/events/events.js","node_modules/browserify/node_modules/process/browser.js","node_modules/delorean/node_modules/es6-promise/dist/commonjs/main.js","node_modules/delorean/node_modules/es6-promise/dist/commonjs/promise/all.js","node_modules/delorean/node_modules/es6-promise/dist/commonjs/promise/asap.js","node_modules/delorean/node_modules/es6-promise/dist/commonjs/promise/config.js","node_modules/delorean/node_modules/es6-promise/dist/commonjs/promise/polyfill.js","node_modules/delorean/node_modules/es6-promise/dist/commonjs/promise/promise.js","node_modules/delorean/node_modules/es6-promise/dist/commonjs/promise/race.js","node_modules/delorean/node_modules/es6-promise/dist/commonjs/promise/reject.js","node_modules/delorean/node_modules/es6-promise/dist/commonjs/promise/resolve.js","node_modules/delorean/node_modules/es6-promise/dist/commonjs/promise/utils.js","node_modules/delorean/src/delorean.js","node_modules/delorean/src/requirements.js"],"names":[],"mappings":"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SAAS,GAAG,KAAK,CAAC;KACxB,CAAC;IACF,YAAY,CAAC,SAAS,CAAC,CAAC;GACzB;CACF,CAAC,CAAC;;;ACZH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"bundle.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var socket = io();\nvar Flux = require('delorean').Flux;\n\nvar fakeMsgID = 0;\n\n\n// var for user's name after ajax call\nvar userName;\n\n\n// Grabs user name from the getUser route\n$.ajax({\n url: '/getName',\n method: 'GET',\n success: function(data){\n   userName = data;\n }\n});\n\n//Creates the array where the message will be stored to be grab and handle later.\nvar Messages = Flux.createStore({\n  messages: [{author: \"sysop\", content: \"Initialized\", id:fakeMsgID}],\n  receiveMessage: function (message) {\n    this.messages.push(message);\n    this.emit('change');\n  },\n  actions: {\n    'RECEIVE_MESSAGE': 'receiveMessage'\n  },\n  getState: function() {\n    return {\n      messages: this.messages\n    }\n  }\n});\n\nvar messages = Messages;\n\nvar MessagesDispatcher = Flux.createDispatcher({\n  receiveMessage: function (message) {\n    this.dispatch('RECEIVE_MESSAGE', message);\n  },\n  getStores: function () {\n    return {\n      messageStore: messages\n    };\n  }\n});\n\n// receives the message and sends the new info to the react create class to be displayed when a message is sent.\nvar MessageActions = {\n  receiveMessage: function (author, content) {\n    MessagesDispatcher.receiveMessage({author: author, content: content, id: fakeMsgID++ });\n  },\n  sendMessage: function (author, content) {\n    socket.emit('sendMessage', {author: author, content: content, id: fakeMsgID++ });\n  }\n};\n\nsocket.on('receiveMessage', function (payload) {\n  MessageActions.receiveMessage(payload.author, payload.content, fakeMsgID++ );\n});\n\nvar MessagesView = React.createClass({displayName: 'MessagesView',\n  mixins: [Flux.mixins.storeListener],\n\n  render: function () {\n    var messages = this.stores.messageStore.messages.map(function (message) {\n      return (\n        <div key={message.id}>\n          <span><strong>{message.author}: </strong></span>\n          <span>{message.content}</span>\n        </div>\n      );\n    });\n\n    return (\n        <div>\n          {messages}\n        </div>\n      );\n  }\n});\n\nvar MessagesSender = React.createClass({displayName: 'MessagesSender',\n  getInitialState: function () {\n    return {message: ''};\n  },\n  handleChange: function () {\n    var value = this.refs.message.getDOMNode().value;\n    this.setState({message: value});\n  },\n  handleKeyUp: function (e) {\n    if (e.keyCode == 13) {\n      var message = this.state.message;\n      MessageActions.sendMessage(userName, message);\n      this.setState({message: ''});\n    }\n  },\n  render: function () {\n    return (\n      <input\n          type          = 'text'\n          ref           = 'message'\n          onChange      = {this.handleChange}\n          onKeyUp       = {this.handleKeyUp}\n          value         = {this.state.message}\n          className     = 'form-control'\n          id            = 'message'\n          placeholder   = 'write your message here'\n          require />\n\n\n    );\n  }\n});\n\nReact.render(\n    <MessagesView dispatcher={MessagesDispatcher} />,\n    document.getElementById('messages')\n);\nReact.render(\n  <MessagesSender dispatcher={MessagesDispatcher} />,\n  document.getElementById('sender')\n);\n","//ajax call to pass user theme information to body class\n$.ajax({\n  method: 'get',\n  url: '/getUser',\n  success: function(data){\n    var themeName = data.theme;\n    var themeChanger = function(theme){\n      var body = document.getElementsByTagName('body')[0];\n      body.className = theme;\n    };\n    themeChanger(themeName);\n  }\n});\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            currentQueue[queueIndex].run();\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\"use strict\";\nvar Promise = require(\"./promise/promise\").Promise;\nvar polyfill = require(\"./promise/polyfill\").polyfill;\nexports.Promise = Promise;\nexports.polyfill = polyfill;","\"use strict\";\n/* global toString */\n\nvar isArray = require(\"./utils\").isArray;\nvar isFunction = require(\"./utils\").isFunction;\n\n/**\n  Returns a promise that is fulfilled when all the given promises have been\n  fulfilled, or rejected if any of them become rejected. The return promise\n  is fulfilled with an array that gives all the values in the order they were\n  passed in the `promises` array argument.\n\n  Example:\n\n  ```javascript\n  var promise1 = RSVP.resolve(1);\n  var promise2 = RSVP.resolve(2);\n  var promise3 = RSVP.resolve(3);\n  var promises = [ promise1, promise2, promise3 ];\n\n  RSVP.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `RSVP.all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  var promise1 = RSVP.resolve(1);\n  var promise2 = RSVP.reject(new Error(\"2\"));\n  var promise3 = RSVP.reject(new Error(\"3\"));\n  var promises = [ promise1, promise2, promise3 ];\n\n  RSVP.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @for RSVP\n  @param {Array} promises\n  @param {String} label\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n*/\nfunction all(promises) {\n  /*jshint validthis:true */\n  var Promise = this;\n\n  if (!isArray(promises)) {\n    throw new TypeError('You must pass an array to all.');\n  }\n\n  return new Promise(function(resolve, reject) {\n    var results = [], remaining = promises.length,\n    promise;\n\n    if (remaining === 0) {\n      resolve([]);\n    }\n\n    function resolver(index) {\n      return function(value) {\n        resolveAll(index, value);\n      };\n    }\n\n    function resolveAll(index, value) {\n      results[index] = value;\n      if (--remaining === 0) {\n        resolve(results);\n      }\n    }\n\n    for (var i = 0; i < promises.length; i++) {\n      promise = promises[i];\n\n      if (promise && isFunction(promise.then)) {\n        promise.then(resolver(i), reject);\n      } else {\n        resolveAll(i, promise);\n      }\n    }\n  });\n}\n\nexports.all = all;","\"use strict\";\nvar browserGlobal = (typeof window !== 'undefined') ? window : {};\nvar BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\nvar local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);\n\n// node\nfunction useNextTick() {\n  return function() {\n    process.nextTick(flush);\n  };\n}\n\nfunction useMutationObserver() {\n  var iterations = 0;\n  var observer = new BrowserMutationObserver(flush);\n  var node = document.createTextNode('');\n  observer.observe(node, { characterData: true });\n\n  return function() {\n    node.data = (iterations = ++iterations % 2);\n  };\n}\n\nfunction useSetTimeout() {\n  return function() {\n    local.setTimeout(flush, 1);\n  };\n}\n\nvar queue = [];\nfunction flush() {\n  for (var i = 0; i < queue.length; i++) {\n    var tuple = queue[i];\n    var callback = tuple[0], arg = tuple[1];\n    callback(arg);\n  }\n  queue = [];\n}\n\nvar scheduleFlush;\n\n// Decide what async method to use to triggering processing of queued callbacks:\nif (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n  scheduleFlush = useNextTick();\n} else if (BrowserMutationObserver) {\n  scheduleFlush = useMutationObserver();\n} else {\n  scheduleFlush = useSetTimeout();\n}\n\nfunction asap(callback, arg) {\n  var length = queue.push([callback, arg]);\n  if (length === 1) {\n    // If length is 1, that means that we need to schedule an async flush.\n    // If additional callbacks are queued before the queue is flushed, they\n    // will be processed by this flush that we are scheduling.\n    scheduleFlush();\n  }\n}\n\nexports.asap = asap;","\"use strict\";\nvar config = {\n  instrument: false\n};\n\nfunction configure(name, value) {\n  if (arguments.length === 2) {\n    config[name] = value;\n  } else {\n    return config[name];\n  }\n}\n\nexports.config = config;\nexports.configure = configure;","\"use strict\";\n/*global self*/\nvar RSVPPromise = require(\"./promise\").Promise;\nvar isFunction = require(\"./utils\").isFunction;\n\nfunction polyfill() {\n  var local;\n\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof window !== 'undefined' && window.document) {\n    local = window;\n  } else {\n    local = self;\n  }\n\n  var es6PromiseSupport = \n    \"Promise\" in local &&\n    // Some of these methods are missing from\n    // Firefox/Chrome experimental implementations\n    \"resolve\" in local.Promise &&\n    \"reject\" in local.Promise &&\n    \"all\" in local.Promise &&\n    \"race\" in local.Promise &&\n    // Older version of the spec had a resolver object\n    // as the arg rather than a function\n    (function() {\n      var resolve;\n      new local.Promise(function(r) { resolve = r; });\n      return isFunction(resolve);\n    }());\n\n  if (!es6PromiseSupport) {\n    local.Promise = RSVPPromise;\n  }\n}\n\nexports.polyfill = polyfill;","\"use strict\";\nvar config = require(\"./config\").config;\nvar configure = require(\"./config\").configure;\nvar objectOrFunction = require(\"./utils\").objectOrFunction;\nvar isFunction = require(\"./utils\").isFunction;\nvar now = require(\"./utils\").now;\nvar all = require(\"./all\").all;\nvar race = require(\"./race\").race;\nvar staticResolve = require(\"./resolve\").resolve;\nvar staticReject = require(\"./reject\").reject;\nvar asap = require(\"./asap\").asap;\n\nvar counter = 0;\n\nconfig.async = asap; // default async is asap;\n\nfunction Promise(resolver) {\n  if (!isFunction(resolver)) {\n    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n  }\n\n  if (!(this instanceof Promise)) {\n    throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n  }\n\n  this._subscribers = [];\n\n  invokeResolver(resolver, this);\n}\n\nfunction invokeResolver(resolver, promise) {\n  function resolvePromise(value) {\n    resolve(promise, value);\n  }\n\n  function rejectPromise(reason) {\n    reject(promise, reason);\n  }\n\n  try {\n    resolver(resolvePromise, rejectPromise);\n  } catch(e) {\n    rejectPromise(e);\n  }\n}\n\nfunction invokeCallback(settled, promise, callback, detail) {\n  var hasCallback = isFunction(callback),\n      value, error, succeeded, failed;\n\n  if (hasCallback) {\n    try {\n      value = callback(detail);\n      succeeded = true;\n    } catch(e) {\n      failed = true;\n      error = e;\n    }\n  } else {\n    value = detail;\n    succeeded = true;\n  }\n\n  if (handleThenable(promise, value)) {\n    return;\n  } else if (hasCallback && succeeded) {\n    resolve(promise, value);\n  } else if (failed) {\n    reject(promise, error);\n  } else if (settled === FULFILLED) {\n    resolve(promise, value);\n  } else if (settled === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nvar PENDING   = void 0;\nvar SEALED    = 0;\nvar FULFILLED = 1;\nvar REJECTED  = 2;\n\nfunction subscribe(parent, child, onFulfillment, onRejection) {\n  var subscribers = parent._subscribers;\n  var length = subscribers.length;\n\n  subscribers[length] = child;\n  subscribers[length + FULFILLED] = onFulfillment;\n  subscribers[length + REJECTED]  = onRejection;\n}\n\nfunction publish(promise, settled) {\n  var child, callback, subscribers = promise._subscribers, detail = promise._detail;\n\n  for (var i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    invokeCallback(settled, child, callback, detail);\n  }\n\n  promise._subscribers = null;\n}\n\nPromise.prototype = {\n  constructor: Promise,\n\n  _state: undefined,\n  _detail: undefined,\n  _subscribers: undefined,\n\n  then: function(onFulfillment, onRejection) {\n    var promise = this;\n\n    var thenPromise = new this.constructor(function() {});\n\n    if (this._state) {\n      var callbacks = arguments;\n      config.async(function invokePromiseCallback() {\n        invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);\n      });\n    } else {\n      subscribe(this, thenPromise, onFulfillment, onRejection);\n    }\n\n    return thenPromise;\n  },\n\n  'catch': function(onRejection) {\n    return this.then(null, onRejection);\n  }\n};\n\nPromise.all = all;\nPromise.race = race;\nPromise.resolve = staticResolve;\nPromise.reject = staticReject;\n\nfunction handleThenable(promise, value) {\n  var then = null,\n  resolved;\n\n  try {\n    if (promise === value) {\n      throw new TypeError(\"A promises callback cannot return that same promise.\");\n    }\n\n    if (objectOrFunction(value)) {\n      then = value.then;\n\n      if (isFunction(then)) {\n        then.call(value, function(val) {\n          if (resolved) { return true; }\n          resolved = true;\n\n          if (value !== val) {\n            resolve(promise, val);\n          } else {\n            fulfill(promise, val);\n          }\n        }, function(val) {\n          if (resolved) { return true; }\n          resolved = true;\n\n          reject(promise, val);\n        });\n\n        return true;\n      }\n    }\n  } catch (error) {\n    if (resolved) { return true; }\n    reject(promise, error);\n    return true;\n  }\n\n  return false;\n}\n\nfunction resolve(promise, value) {\n  if (promise === value) {\n    fulfill(promise, value);\n  } else if (!handleThenable(promise, value)) {\n    fulfill(promise, value);\n  }\n}\n\nfunction fulfill(promise, value) {\n  if (promise._state !== PENDING) { return; }\n  promise._state = SEALED;\n  promise._detail = value;\n\n  config.async(publishFulfillment, promise);\n}\n\nfunction reject(promise, reason) {\n  if (promise._state !== PENDING) { return; }\n  promise._state = SEALED;\n  promise._detail = reason;\n\n  config.async(publishRejection, promise);\n}\n\nfunction publishFulfillment(promise) {\n  publish(promise, promise._state = FULFILLED);\n}\n\nfunction publishRejection(promise) {\n  publish(promise, promise._state = REJECTED);\n}\n\nexports.Promise = Promise;","\"use strict\";\n/* global toString */\nvar isArray = require(\"./utils\").isArray;\n\n/**\n  `RSVP.race` allows you to watch a series of promises and act as soon as the\n  first promise given to the `promises` argument fulfills or rejects.\n\n  Example:\n\n  ```javascript\n  var promise1 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve(\"promise 1\");\n    }, 200);\n  });\n\n  var promise2 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve(\"promise 2\");\n    }, 100);\n  });\n\n  RSVP.race([promise1, promise2]).then(function(result){\n    // result === \"promise 2\" because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `RSVP.race` is deterministic in that only the state of the first completed\n  promise matters. For example, even if other promises given to the `promises`\n  array argument are resolved, but the first completed promise has become\n  rejected before the other promises became fulfilled, the returned promise\n  will become rejected:\n\n  ```javascript\n  var promise1 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve(\"promise 1\");\n    }, 200);\n  });\n\n  var promise2 = new RSVP.Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error(\"promise 2\"));\n    }, 100);\n  });\n\n  RSVP.race([promise1, promise2]).then(function(result){\n    // Code here never runs because there are rejected promises!\n  }, function(reason){\n    // reason.message === \"promise2\" because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  @method race\n  @for RSVP\n  @param {Array} promises array of promises to observe\n  @param {String} label optional string for describing the promise returned.\n  Useful for tooling.\n  @return {Promise} a promise that becomes fulfilled with the value the first\n  completed promises is resolved with if the first completed promise was\n  fulfilled, or rejected with the reason that the first completed promise\n  was rejected with.\n*/\nfunction race(promises) {\n  /*jshint validthis:true */\n  var Promise = this;\n\n  if (!isArray(promises)) {\n    throw new TypeError('You must pass an array to race.');\n  }\n  return new Promise(function(resolve, reject) {\n    var results = [], promise;\n\n    for (var i = 0; i < promises.length; i++) {\n      promise = promises[i];\n\n      if (promise && typeof promise.then === 'function') {\n        promise.then(resolve, reject);\n      } else {\n        resolve(promise);\n      }\n    }\n  });\n}\n\nexports.race = race;","\"use strict\";\n/**\n  `RSVP.reject` returns a promise that will become rejected with the passed\n  `reason`. `RSVP.reject` is essentially shorthand for the following:\n\n  ```javascript\n  var promise = new RSVP.Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  var promise = RSVP.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @for RSVP\n  @param {Any} reason value that the returned promise will be rejected with.\n  @param {String} label optional string for identifying the returned promise.\n  Useful for tooling.\n  @return {Promise} a promise that will become rejected with the given\n  `reason`.\n*/\nfunction reject(reason) {\n  /*jshint validthis:true */\n  var Promise = this;\n\n  return new Promise(function (resolve, reject) {\n    reject(reason);\n  });\n}\n\nexports.reject = reject;","\"use strict\";\nfunction resolve(value) {\n  /*jshint validthis:true */\n  if (value && typeof value === 'object' && value.constructor === this) {\n    return value;\n  }\n\n  var Promise = this;\n\n  return new Promise(function(resolve) {\n    resolve(value);\n  });\n}\n\nexports.resolve = resolve;","\"use strict\";\nfunction objectOrFunction(x) {\n  return isFunction(x) || (typeof x === \"object\" && x !== null);\n}\n\nfunction isFunction(x) {\n  return typeof x === \"function\";\n}\n\nfunction isArray(x) {\n  return Object.prototype.toString.call(x) === \"[object Array]\";\n}\n\n// Date.now is not available in browsers < IE9\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility\nvar now = Date.now || function() { return new Date().getTime(); };\n\n\nexports.objectOrFunction = objectOrFunction;\nexports.isFunction = isFunction;\nexports.isArray = isArray;\nexports.now = now;","(function (DeLorean) {\n  'use strict';\n\n  // There are two main concepts in Flux structure: **Dispatchers** and **Stores**.\n  // Action Creators are simply helpers but doesn't require any framework level\n  // abstraction.\n\n  var Dispatcher, Store;\n\n  // ## Private Helper Functions\n\n  // Helper functions are private functions to be used in codebase.\n  // It's better using two underscore at the beginning of the function.\n\n  /* `__hasOwn` function is a shortcut for `Object#hasOwnProperty` */\n  function __hasOwn(object, prop) {\n    return Object.prototype.hasOwnProperty.call(object, prop);\n  }\n\n  // Use `__generateActionName` function to generate action names.\n  // E.g. If you create an action with name `hello` it will be\n  // `action:hello` for the Flux.\n  function __generateActionName(name) {\n    return 'action:' + name;\n  }\n\n  /* It's used by the schemes to save the original version (not calculated)\n     of the data. */\n  function __generateOriginalName(name) {\n    return 'original:' + name;\n  }\n\n  // `__findDispatcher` is a private function for **React components**.\n  function __findDispatcher(view) {\n     // Provide a useful error message if no dispatcher is found\n    if (DeLorean.dispatcher == null) {\n      throw 'No dispatcher found. The DeLoreanJS mixin requires a \"dispatcher\" has been created using Flux.createDispatcher.';\n    }\n    return DeLorean.dispatcher;\n  }\n\n  // `__clone` creates a deep copy of an object.\n  function __clone(obj) {\n    if (obj === null || typeof obj !== 'object') { return obj; }\n    var copy = obj.constructor();\n    for (var attr in obj) {\n      if (__hasOwn(obj, attr)) {\n        copy[attr] = __clone(obj[attr]);\n      }\n    }\n    return copy;\n  }\n\n  // `__extend` adds props to obj\n  function __extend(obj, props) {\n    props = __clone(props);\n    for (var prop in props) {\n      if (props.hasOwnProperty(prop)) {\n        obj[prop] = props[prop];\n      }\n    }\n    return obj;\n  }\n\n  // ## Dispatcher\n\n  // The dispatcher is **the central hub** that **manages all data flow** in\n  // a Flux application. It is essentially a _registry of callbacks into the\n  // stores_. Each store registers itself and provides a callback. When the\n  // dispatcher responds to an action, all stores in the application are sent\n  // the data payload provided by the action via the callbacks in the registry.\n  Dispatcher = (function () {\n\n    // ### Dispatcher Helpers\n\n    // Rollback listener adds a `rollback` event listener to the bunch of\n    // stores.\n    function __rollbackListener(stores) {\n\n      function __listener() {\n        for (var i in stores) {\n          stores[i].listener.emit('__rollback');\n        }\n      }\n\n      /* If any of them fires `rollback` event, all of the stores\n         will be emitted to be rolled back with `__rollback` event. */\n      for (var j in stores) {\n        stores[j].listener.on('rollback', __listener);\n      }\n    }\n\n    // ### Dispatcher Prototype\n    function Dispatcher(stores) {\n      var self = this;\n      // `DeLorean.EventEmitter` is `require('events').EventEmitter` by default.\n      // you can change it using `DeLorean.Flux.define('EventEmitter', AnotherEventEmitter)`\n      this.listener = new DeLorean.EventEmitter();\n      this.stores = stores;\n\n      /* Stores should be listened for rollback events. */\n      __rollbackListener(Object.keys(stores).map(function (key) {\n        return stores[key];\n      }));\n    }\n\n    // `dispatch` method dispatch the event with `data` (or **payload**)\n    Dispatcher.prototype.dispatch = function () {\n      var self = this, stores, deferred, args;\n      args = Array.prototype.slice.call(arguments);\n\n      this.listener.emit.apply(this.listener, ['dispatch'].concat(args));\n\n      /* Stores are key-value pairs. Collect store instances into an array. */\n      stores = (function () {\n        var stores = [], store;\n        for (var storeName in self.stores) {\n          store = self.stores[storeName];\n          /* Store value must be an _instance of Store_. */\n          if (!store instanceof Store) {\n            throw 'Given store is not a store instance';\n          }\n          stores.push(store);\n        }\n        return stores;\n      }());\n\n      // Store instances should wait for finish. So you can know if all the\n      // stores are dispatched properly.\n      deferred = this.waitFor(stores, args[0]);\n\n      /* Payload should send to all related stores. */\n      for (var storeName in self.stores) {\n        self.stores[storeName].dispatchAction.apply(self.stores[storeName], args);\n      }\n\n      // `dispatch` returns deferred object you can just use **promise**\n      // for dispatching: `dispatch(..).then(..)`.\n      return deferred;\n    };\n\n    // `waitFor` is actually a _semi-private_ method. Because it's kind of internal\n    // and you don't need to call it from outside most of the times. It takes\n    // array of store instances (`[Store, Store, Store, ...]`). It will create\n    // a promise and return it. _Whenever store changes, it resolves the promise_.\n    Dispatcher.prototype.waitFor = function (stores, actionName) {\n      var self = this, promises;\n      promises = (function () {\n        var __promises = [], promise;\n\n        /* `__promiseGenerator` generates a simple promise that resolves itself when\n            related store is changed. */\n        function __promiseGenerator(store) {\n          // `DeLorean.Promise` is `require('es6-promise').Promise` by default.\n          // you can change it using `DeLorean.Flux.define('Promise', AnotherPromise)`\n          return new DeLorean.Promise(function (resolve, reject) {\n            store.listener.once('change', resolve);\n          });\n        }\n\n        for (var i in stores) {\n          // Only generate promises for stores that ae listening for this action\n          if (stores[i].actions && stores[i].actions[actionName] != null) {\n            promise = __promiseGenerator(stores[i]);\n            __promises.push(promise);\n          }\n        }\n        return __promises;\n      }());\n      // When all the promises are resolved, dispatcher emits `change:all` event.\n      return DeLorean.Promise.all(promises).then(function () {\n        self.listener.emit('change:all');\n      });\n    };\n\n    // `registerAction` method adds a method to the prototype. So you can just use\n    // `dispatcherInstance.actionName()`.\n    Dispatcher.prototype.registerAction = function (action, callback) {\n      /* The callback must be a function. */\n      if (typeof callback === 'function') {\n        this[action] = callback.bind(this.stores);\n      } else {\n        throw 'Action callback should be a function.';\n      }\n    };\n\n    // `register` method adds an global action callback to the dispatcher.\n    Dispatcher.prototype.register = function (callback) {\n      /* The callback must be a function. */\n      if (typeof callback === 'function') {\n        this.listener.on('dispatch', callback);\n      } else {\n        throw 'Global callback should be a function.';\n      }\n    };\n\n    // `getStore` returns the store from stores hash.\n    // You can also use `dispatcherInstance.stores[storeName]` but\n    // it checks if the store really exists.\n    Dispatcher.prototype.getStore = function (storeName) {\n      if (!this.stores[storeName]) {\n        throw 'Store ' + storeName + ' does not exist.';\n      }\n      return this.stores[storeName].getState();\n    };\n\n    // ### Shortcuts\n\n    Dispatcher.prototype.on = function () {\n      return this.listener.on.apply(this.listener, arguments);\n    };\n\n    Dispatcher.prototype.off = function () {\n      return this.listener.removeListener.apply(this.listener, arguments);\n    };\n\n    Dispatcher.prototype.emit = function () {\n      return this.listener.emit.apply(this.listener, arguments);\n    };\n\n    return Dispatcher;\n  }());\n\n  // ## Store\n\n  // Stores contain the application state and logic. Their role is somewhat similar\n  // to a model in a traditional MVC, but they manage the state of many objects.\n  // Unlike MVC models, they are not instances of one object, nor are they the\n  // same as Backbone's collections. More than simply managing a collection of\n  // ORM-style objects, stores manage the application state for a particular\n  // domain within the application.\n  Store = (function () {\n\n    // ### Store Prototype\n    function Store(args) {\n      if (!this.state) {\n        this.state = {};\n      }\n\n      // `DeLorean.EventEmitter` is `require('events').EventEmitter` by default.\n      // you can change it using `DeLorean.Flux.define('EventEmitter', AnotherEventEmitter)`\n      this.listener = new DeLorean.EventEmitter();\n      this.bindActions();\n      this.buildScheme();\n\n      this.initialize.apply(this, arguments);\n    }\n\n    Store.prototype.initialize = function () {\n\n    };\n\n    Store.prototype.get = function (arg) {\n      return this.state[arg];\n    };\n\n    // `set` method updates the data defined at the `scheme` of the store.\n    Store.prototype.set = function (arg1, value) {\n      var changedProps = [];\n      if (typeof arg1 === 'object') {\n        for (var keyName in arg1) {\n          changedProps.push(keyName);\n          this.setValue(keyName, arg1[keyName]);\n        }\n      } else {\n        changedProps.push(arg1);\n        this.setValue(arg1, value);\n      }\n      this.recalculate(changedProps);\n      return this.state[arg1];\n    };\n\n    // `set` method updates the data defined at the `scheme` of the store.\n    Store.prototype.setValue = function (key, value) {\n      var scheme = this.scheme, definition;\n      if (scheme && this.scheme[key]) {\n        definition = scheme[key];\n\n        // This will allow you to directly set falsy values before falling back to the definition default\n        this.state[key] = (typeof value !== 'undefined') ? value : definition.default;\n\n        if (typeof definition.calculate === 'function') {\n          this.state[__generateOriginalName(key)] = value;\n          this.state[key] = definition.calculate.call(this, value);\n        }\n      } else {\n        // Scheme **must** include the key you wanted to set.\n        if (console != null) {\n          console.warn('Scheme must include the key, ' + key + ', you are trying to set. ' + key + ' will NOT be set on the store.');\n        }\n      }\n      return this.state[key];\n    };\n\n    // Removes the scheme format and standardizes all the shortcuts.\n    // If you run `formatScheme({name: 'joe'})` it will return you\n    // `{name: {default: 'joe'}}`. Also if you run `formatScheme({fullname: function () {}})`\n    // it will return `{fullname: {calculate: function () {}}}`.\n    Store.prototype.formatScheme = function (scheme) {\n      var formattedScheme = {}, definition, defaultValue, calculatedValue;\n      for (var keyName in scheme) {\n        definition = scheme[keyName];\n        defaultValue = null;\n        calculatedValue = null;\n\n        formattedScheme[keyName] = {default: null};\n\n        /* {key: 'value'} will be {key: {default: 'value'}} */\n        defaultValue = (definition && typeof definition === 'object') ?\n                        definition.default : definition;\n        formattedScheme[keyName].default = defaultValue;\n\n        /* {key: function () {}} will be {key: {calculate: function () {}}} */\n        if (definition && typeof definition.calculate === 'function') {\n          calculatedValue = definition.calculate;\n          /* Put a dependency array on formattedSchemes with calculate defined */\n          if (definition.deps) {\n            formattedScheme[keyName].deps = definition.deps;\n          } else {\n            formattedScheme[keyName].deps = [];\n          }\n\n        } else if (typeof definition === 'function') {\n          calculatedValue = definition;\n        }\n        if (calculatedValue) {\n          formattedScheme[keyName].calculate = calculatedValue;\n        }\n      }\n      return formattedScheme;\n    };\n\n    /* Applying `scheme` to the store if exists. */\n    Store.prototype.buildScheme = function () {\n      var scheme, calculatedData, keyName, definition, dependencyMap, dependents, dep, changedProps = [];\n\n      if (typeof this.scheme === 'object') {\n        /* Scheme must be formatted to standardize the keys. */\n        scheme = this.scheme = this.formatScheme(this.scheme);\n        dependencyMap = this.__dependencyMap = {};\n\n        /* Set the defaults first */\n        for (keyName in scheme) {\n          definition = scheme[keyName];\n          this.state[keyName] = __clone(definition.default);\n        }\n\n        /* Set the calculations */\n        for (keyName in scheme) {\n          definition = scheme[keyName];\n          if (definition.calculate) {\n            // Create a dependency map - {keyName: [arrayOfKeysThatDependOnIt]}\n            dependents = definition.deps || [];\n\n            for (var i = 0; i < dependents.length; i++) {\n              dep = dependents[i];\n              if (dependencyMap[dep] == null) {\n                dependencyMap[dep] = [];\n              }\n              dependencyMap[dep].push(keyName);\n            }\n\n            this.state[__generateOriginalName(keyName)] = definition.default;\n            this.state[keyName] = definition.calculate.call(this, definition.default);\n            changedProps.push(keyName);\n          }\n        }\n        // Recalculate any properties dependent on those that were just set\n        this.recalculate(changedProps);\n      }\n    };\n\n    Store.prototype.recalculate = function (changedProps) {\n      var scheme = this.scheme, dependencyMap = this.__dependencyMap, didRun = [], definition, keyName, dependents, dep;\n      // Only iterate over the properties that just changed\n      for (var i = 0; i < changedProps.length; i++) {\n        dependents = dependencyMap[changedProps[i]];\n        // If there are no properties dependent on this property, do nothing\n        if (dependents == null) {\n          continue;\n        }\n        // Iterate over the dependendent properties\n        for (var d = 0; d < dependents.length; d++) {\n          dep = dependents[d];\n          // Do nothing if this value has already been recalculated on this change batch\n          if (didRun.indexOf(dep) !== -1) {\n            continue;\n          }\n          // Calculate this value\n          definition = scheme[dep];\n          this.state[dep] = definition.calculate.call(this,\n                            this.state[__generateOriginalName(dep)] || definition.default);\n\n          // Make sure this does not get calculated again in this change batch\n          didRun.push(dep);\n        }\n      }\n      // Update Any deps on the deps\n      if (didRun.length > 0) {\n        this.recalculate(didRun);\n      }\n      this.listener.emit('change');\n    };\n\n    Store.prototype.getState = function () {\n      return this.state;\n    };\n\n    Store.prototype.clearState = function () {\n      this.state = {};\n      return this;\n    };\n\n    Store.prototype.resetState = function () {\n      this.buildScheme();\n      this.listener.emit('change');\n      return this;\n    };\n\n    // Stores must have a `actions` hash of `actionName: methodName`\n    // `methodName` is the `this.store`'s prototype method..\n    Store.prototype.bindActions = function () {\n      var callback;\n\n      this.emitChange = this.listener.emit.bind(this.listener, 'change');\n      this.emitRollback = this.listener.emit.bind(this.listener, 'rollback');\n      this.rollback = this.listener.on.bind(this.listener, '__rollback');\n      this.emit = this.listener.emit.bind(this.listener);\n\n      for (var actionName in this.actions) {\n        if (__hasOwn(this.actions, actionName)) {\n          callback = this.actions[actionName];\n          if (typeof this[callback] !== 'function') {\n            throw 'Callback \\'' + callback + '\\' defined for action \\'' + actionName + '\\' should be a method defined on the store!';\n          }\n          /* And `actionName` should be a name generated by `__generateActionName` */\n          this.listener.on(__generateActionName(actionName), this[callback].bind(this));\n        }\n      }\n    };\n\n    // `dispatchAction` called from a dispatcher. You can also call anywhere but\n    // you probably won't need to do. It simply **emits an event with a payload**.\n    Store.prototype.dispatchAction = function (actionName, data) {\n      this.listener.emit(__generateActionName(actionName), data);\n    };\n\n    // ### Shortcuts\n\n    // `listenChanges` is a shortcut for `Object.observe` usage. You can just use\n    // `Object.observe(object, function () { ... })` but everytime you use it you\n    // repeat yourself. DeLorean has a shortcut doing this properly.\n    Store.prototype.listenChanges = function (object) {\n      var self = this, observer;\n      if (!Object.observe) {\n        console.error('Store#listenChanges method uses Object.observe, you should fire changes manually.');\n        return;\n      }\n\n      observer = Array.isArray(object) ? Array.observe : Object.observe;\n\n      observer(object, function (changes) {\n        self.listener.emit('change', changes);\n      });\n    };\n\n    // `onChange` simply listens changes and calls a callback. Shortcut for\n    // a `on('change')` command.\n    Store.prototype.onChange = function (callback) {\n      this.listener.on('change', callback);\n    };\n\n    return Store;\n  }());\n\n  // ### Flux Wrapper\n  DeLorean.Flux = {\n\n    // `createStore` generates a store based on the definition\n    createStore: function (definition) {\n      /* store parameter must be an `object` */\n      if (typeof definition !== 'object') {\n        throw 'Stores should be defined by passing the definition to the constructor';\n      }\n\n      // extends the store with the definition attributes\n      var Child = function () { return Store.apply(this, arguments); };\n      var Surrogate = function () { this.constructor = Child; };\n      Surrogate.prototype = Store.prototype;\n      Child.prototype = new Surrogate();\n\n      __extend(Child.prototype, definition);\n\n      return new Child();\n    },\n\n    // `createDispatcher` generates a dispatcher with actions to dispatch.\n    /* `actionsToDispatch` should be an object. */\n    createDispatcher: function (actionsToDispatch) {\n      var actionsOfStores, dispatcher, callback, triggers, triggerMethod;\n\n      // If it has `getStores` method it should be get and pass to the `Dispatcher`\n      if (typeof actionsToDispatch.getStores === 'function') {\n        actionsOfStores = actionsToDispatch.getStores();\n      }\n\n      /* If there are no stores defined, it's an empty object. */\n      dispatcher = new Dispatcher(actionsOfStores || {});\n\n      /* Now call `registerAction` method for every action. */\n      for (var actionName in actionsToDispatch) {\n        if (__hasOwn(actionsToDispatch, actionName)) {\n          /* `getStores` & `viewTriggers` are special properties, it's not an action. Also an extra check to make sure we're binding to a function */\n          if (actionName !== 'getStores' && actionName !== 'viewTriggers' && typeof actionsToDispatch[actionName] === 'function') {\n            callback = actionsToDispatch[actionName];\n            dispatcher.registerAction(actionName, callback.bind(dispatcher));\n          }\n        }\n      }\n\n      /* Bind triggers */\n      triggers = actionsToDispatch.viewTriggers;\n      for (var triggerName in triggers) {\n        triggerMethod = triggers[triggerName];\n        if (typeof dispatcher[triggerMethod] === 'function') {\n          dispatcher.on(triggerName, dispatcher[triggerMethod]);\n        } else {\n          if (console != null) {\n            console.warn(triggerMethod + ' should be a method defined on your dispatcher. The ' + triggerName + ' trigger will not be bound to any method.');\n          }\n        }\n      }\n\n      // Allow only a single dispatcher\n      if (DeLorean.dispatcher != null) {\n        if (console != null) {\n          console.warn('You are attempting to create more than one dispatcher. DeLorean is intended to be used with a single dispatcher. This latest dispatcher created will overwrite any previous versions.');\n        }\n      }\n\n      // Create an internal reference to the dispathcer instance. This allows it to be found by the mixins.\n      DeLorean.dispatcher = dispatcher;\n\n      return dispatcher;\n    },\n    // ### `DeLorean.Flux.define`\n    // It's a key to _hack_ DeLorean easily. You can just inject something\n    // you want to define.\n    define: function (key, value) {\n      DeLorean[key] = value;\n    }\n  };\n\n  // Store and Dispatcher are the only base classes of DeLorean.\n  DeLorean.Dispatcher = Dispatcher;\n  DeLorean.Store = Store;\n\n  // ## Built-in React Mixin\n  DeLorean.Flux.mixins = {\n    // It should be inserted to the React components which\n    // used in Flux.\n    // Simply `mixin: [Flux.mixins.storeListener]` will work.\n    storeListener: {\n\n      trigger: function () {\n        this.__dispatcher.emit.apply(this.__dispatcher, arguments);\n      },\n\n      // After the component mounted, listen changes of the related stores\n      componentDidMount: function () {\n        var self = this, store, storeName;\n\n        /* `__changeHandler` is a **listener generator** to pass to the `onChange` function. */\n        function __changeHandler(store, storeName) {\n          return function () {\n            var state, args;\n            /* If the component is mounted, change state. */\n            if (self.isMounted()) {\n              self.setState(self.getStoreStates());\n            }\n            // When something changes it calls the components `storeDidChanged` method if exists.\n            if (self.storeDidChange) {\n              args = [storeName].concat(Array.prototype.slice.call(arguments, 0));\n              self.storeDidChange.apply(self, args);\n            }\n          };\n        }\n\n        // Remember the change handlers so they can be removed later\n        this.__changeHandlers = {};\n\n        /* Generate and bind the change handlers to the stores. */\n        for (storeName in this.__watchStores) {\n          if (__hasOwn(this.stores, storeName)) {\n            store = this.stores[storeName];\n            this.__changeHandlers[storeName] = __changeHandler(store, storeName);\n            store.onChange(this.__changeHandlers[storeName]);\n          }\n        }\n      },\n\n      // When a component unmounted, it should stop listening.\n      componentWillUnmount: function () {\n        for (var storeName in this.__changeHandlers) {\n          if (__hasOwn(this.stores, storeName)) {\n            var store = this.stores[storeName];\n            store.listener.removeListener('change', this.__changeHandlers[storeName]);\n          }\n        }\n      },\n\n      getInitialState: function () {\n        var self = this, state, storeName;\n\n        /* The dispatcher should be easy to access and it should use `__findDispatcher`\n           method to find the parent dispatchers. */\n        this.__dispatcher = __findDispatcher(this);\n\n        // If `storesDidChange` method presents, it'll be called after all the stores\n        // were changed.\n        if (this.storesDidChange) {\n          this.__dispatcher.on('change:all', function () {\n            self.storesDidChange();\n          });\n        }\n\n        // Since `dispatcher.stores` is harder to write, there's a shortcut for it.\n        // You can use `this.stores` from the React component.\n        this.stores = this.__dispatcher.stores;\n\n        this.__watchStores = {};\n        if (this.watchStores != null) {\n          for (var i = 0; i < this.watchStores.length;  i++) {\n            storeName = this.watchStores[i];\n            this.__watchStores[storeName] = this.stores[storeName];\n          }\n        } else {\n          this.__watchStores = this.stores;\n          if (console != null && Object.keys != null && Object.keys(this.stores).length > 4) {\n            console.warn('Your component is watching changes on all stores, you may want to define a \"watchStores\" property in order to only watch stores relevant to this component.');\n          }\n        }\n\n        return this.getStoreStates();\n      },\n\n      getStoreStates: function () {\n        var state = {stores: {}}, store;\n\n        /* Set `state.stores` for all present stores with a `setState` method defined. */\n        for (var storeName in this.__watchStores) {\n          if (__hasOwn(this.stores, storeName)) {\n            state.stores[storeName] = this.__watchStores[storeName].getState();\n          }\n        }\n        return state;\n      },\n\n      // `getStore` is a shortcut to get the store from the state.\n      getStore: function (storeName) {\n        if (console != null && typeof this.__watchStores[storeName] === 'undefined') {\n          var message;\n          message = 'Attempt to getStore ' + storeName + ' failed. ';\n          message += typeof this.stores[storeName] === 'undefined' ? 'It is not defined on the dispatcher. ' : 'It is not being watched by the component. ';\n          message += this.constructor != null && this.constructor.displayName != null ? 'Check the ' + this.constructor.displayName + ' component.' : '';\n          console.warn(message);\n        }\n        return this.state.stores[storeName];\n      }\n    }\n  };\n\n  // ## DeLorean API\n  // DeLorean can be used in **CommonJS** projects.\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n\n    var requirements = require('./requirements');\n    for (var requirement in requirements) {\n      DeLorean.Flux.define(requirement, requirements[requirement]);\n    }\n    module.exports = DeLorean;\n\n  // It can be also used in **AMD** projects, too.\n  // And if there is no module system initialized, just pass the DeLorean\n  // to the `window`.\n  } else {\n    if (typeof define === 'function' && define.amd) {\n      define(['./requirements.js'], function (requirements) {\n        // Import Modules in require.js pattern\n        for (var requirement in requirements) {\n          DeLorean.Flux.define(requirement, requirements[requirement]);\n        }\n\n        return DeLorean;\n      });\n    } else {\n      window.DeLorean = DeLorean;\n    }\n  }\n\n})({});\n","// ## Dependency injection file.\n\n// You can change dependencies using `DeLorean.Flux.define`. There are\n// two dependencies now: `EventEmitter` and `Promise`\nvar requirements;\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n  module.exports = requirements = {\n    // DeLorean uses **Node.js native EventEmitter** for event emittion\n    EventEmitter: require('events').EventEmitter,\n    // and **es6-promise** for Deferred object management.\n    Promise: require('es6-promise').Promise\n  };\n} else if (typeof define === 'function' && define.amd) {\n  define(function (require, exports, module) {\n    var events = require('events'),\n        promise = require('es6-promise');\n\n    // Return the module value - http://requirejs.org/docs/api.html#cjsmodule\n    // Using simplified wrapper\n    return {\n      // DeLorean uses **Node.js native EventEmitter** for event emittion\n      EventEmitter: require('events').EventEmitter,\n      // and **es6-promise** for Deferred object management.\n      Promise: require('es6-promise').Promise\n    };\n  });\n} else {\n  window.DeLorean = DeLorean;\n}\n\n// It's better you don't change them if you really need to.\n\n// This library needs to work for Browserify and also standalone.\n// If DeLorean is defined, it means it's called from the browser, not\n// the browserify.\n\nif (typeof DeLorean !== 'undefined') {\n  for (var requirement in requirements) {\n    DeLorean.Flux.define(requirement, requirements[requirement]);\n  }\n}\n"]}